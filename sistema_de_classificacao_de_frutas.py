# -*- coding: utf-8 -*-
"""Sistema de classificação de Frutas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18WcBxZN8sB58aYWKNSkR_BkxJhKJF0JC

# Imports
"""

import os
import cv2
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

import numpy as np  # Biblioteca para manipulação de arrays e cálculos numéricos
import tensorflow as tf  # Framework de aprendizado de máquina e deep learning
from tensorflow.keras.models import Sequential  # Classe para criar modelos sequenciais
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, LSTM, Dense, Dropout, TimeDistributed  # Camadas usadas na CNN e RNN
from tensorflow.keras.datasets import cifar10  # Dataset CIFAR-10 para treinamento e teste
from tensorflow.keras.utils import to_categorical  # Função para converter rótulos em one-hot encoding
import matplotlib.pyplot as plt  # Biblioteca para visualização de gráficos

#importando bibliotecas necessário
import numpy as np
from tensorflow.keras import models, layers
from tensorflow.keras.datasets import mnist


from sklearn.model_selection import train_test_split

"""# 2. Descrição do processo de pré-processamento das imagens;


"""

from google.colab import drive
drive.mount('/content/drive')

import requests, zipfile, io, os

url = "https://raw.githubusercontent.com/Jo4oPaulo/Classficador-de-Frutas/main/frutas.zip"

# Faz o download
response = requests.get(url)
response.raise_for_status()

extract_path = "frutas"
os.makedirs(extract_path, exist_ok=True)

# Descompacta direto da memória
with zipfile.ZipFile(io.BytesIO(response.content)) as zip_ref:
    zip_ref.extractall(extract_path)

print(f"Download concluído! Arquivos extraídos em: {extract_path}")

# Categorizando
fruits = {'apple':0, 'orange':1, 'banana':2}
fruits_index_class = {0:'apple',1: 'orange',2:'banana'}


TRAIN_PATH = 'frutas/frutas/train/'
TEST_PATH = 'frutas/frutas/test/'
PREDICT_PATH = 'frutas/frutas/predict/'

def load_images_from_folder(folder_path, img_size=(100, 100)):
    images = []
    labels = []
    class_names = []

    for class_name in os.listdir(folder_path):
        class_path = os.path.join(folder_path, class_name)
        class_name = class_name.lower()
        if os.path.isdir(class_path):
            class_names.append(class_name)
            if class_name in fruits.keys():
              for filename in os.listdir(class_path):
                  img_path = os.path.join(class_path, filename)
                  img = cv2.imread(img_path)

                  img = cv2.resize(img, img_size)
                  img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter para RGB
                  images.append(img)
                  labels.append(class_name)

    return np.array(images), np.array(labels), class_names

images_train, labels_train, _ = load_images_from_folder(TRAIN_PATH)
images_test, labels_test, _ = load_images_from_folder(TEST_PATH)

# Categorizando
fruits = {'apple':0, 'orange':1, 'banana':2}
fruits_index_class = {0:'apple',1: 'orange',2:'banana'}


TRAIN_PATH = 'frutas/frutas/train/'
TEST_PATH = 'frutas/frutas/test/'
PREDICT_PATH = 'frutas/frutas/predict/'

def load_images_from_folder(folder_path, img_size=(100, 100)):
    images = []
    labels = []
    class_names = []

    for class_name in os.listdir(folder_path):
        class_path = os.path.join(folder_path, class_name)
        class_name = class_name.lower()
        if os.path.isdir(class_path):
            class_names.append(class_name)
            if class_name in fruits.keys():
              for filename in os.listdir(class_path):
                  img_path = os.path.join(class_path, filename)
                  img = cv2.imread(img_path)

                  img = cv2.resize(img, img_size)
                  img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter para RGB
                  images.append(img)
                  labels.append(class_name)

    return np.array(images), np.array(labels), class_names

images_train, labels_train, _ = load_images_from_folder(TRAIN_PATH)
images_test, labels_test, _ = load_images_from_folder(TEST_PATH)

def get_data():
  train = images_train / 255
  test = images_test / 255

  l_train = np.array([fruits[x] for x in labels_train])
  l_test = np.array([fruits[x] for x in labels_test])

  return train, test, l_train, l_test,


X_train, X_test, y_train, y_test = get_data()


#images = images_train / 255
#labels_normal = np.array( [fruits[x] for x in labels_train])
#X_train, X_test, y_train, y_test = train_test_split(images, labels_normal, test_size=0.2, random_state=42)

print(f"Train Shape:{X_train.shape}")
print(f"Test Shape:{X_test.shape}")

"""# Apresentação do modelo de rede neural em Python"""

def create_simple_cnn():
    model = models.Sequential([
        # Primeira camada convolucional
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 3)),
        layers.MaxPooling2D((2, 2)),

        # Segunda camada convolucional
        layers.Conv2D(64, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),

        # Terceira camada convolucional
        layers.Conv2D(64, (3, 3), activation='relu'),

        # Camadas densas
        layers.Flatten(),
        layers.Dropout(0.5),  # Previne overfitting
        layers.Dense(64, activation='relu'),
        layers.Dense(3, activation='softmax')
    ])
    return model

model = create_simple_cnn()
model.summary()

# Compilando o modelo
# Utilizando o Modelo Adam, a função de perda para classficação categórica e métrica de acurácia
model.compile(
    optimizer = "adam",
    loss = "sparse_categorical_crossentropy",
    metrics=["accuracy"]
)

"""# Treinamento"""

history = model.fit(X_train, y_train, epochs=42, batch_size=32)

"""# Predição"""

test_loss, test_acc = model.evaluate(X_test, y_test)
print(f"Acurácia dos conjuntos de tests: {test_acc}")

predictions = model.predict(X_test)

for (index, prediction) in enumerate(predictions):
  index_pred_class = np.argmax(prediction)


  print(f"PRED: [{fruits_index_class[index_pred_class]}], REAL CLASS[{fruits_index_class[y_test[index]]}]", "✅"if index_pred_class == y_test[index] else "❌")