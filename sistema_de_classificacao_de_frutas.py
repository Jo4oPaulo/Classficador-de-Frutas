# -*- coding: utf-8 -*-
"""Sistema de classificação de Frutas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18WcBxZN8sB58aYWKNSkR_BkxJhKJF0JC

# Imports
"""

import os
import cv2
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

import numpy as np  # Biblioteca para manipulação de arrays e cálculos numéricos
import tensorflow as tf  # Framework de aprendizado de máquina e deep learning
from tensorflow.keras.models import Sequential  # Classe para criar modelos sequenciais
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, LSTM, Dense, Dropout, TimeDistributed  # Camadas usadas na CNN e RNN
from tensorflow.keras.datasets import cifar10  # Dataset CIFAR-10 para treinamento e teste
from tensorflow.keras.utils import to_categorical  # Função para converter rótulos em one-hot encoding
import matplotlib.pyplot as plt  # Biblioteca para visualização de gráficos

#importando bibliotecas necessário
import numpy as np
from tensorflow.keras import models, layers
from tensorflow.keras.datasets import mnist


from sklearn.model_selection import train_test_split

"""# 2. Descrição do processo de pré-processamento das imagens;


"""

from google.colab import drive
drive.mount('/content/drive')

import kagglehub

# Download latest version

dataset_dir = "./kagglehub/fruit-classification10-class"
os.makedirs(dataset_dir, exist_ok=True)

try:
  path = kagglehub.dataset_download(
    "karimabdulnabi/fruit-classification10-class",
    path=dataset_dir)
  print("Path to dataset files:", path)
except (ValueError) as err:
  print(err)

import os
import cv2
import os
import numpy as np

fruits = {'Apple':0, 'orange':1, 'Banana':2}
fruits_index_class = {0:'Apple',1: 'orange',2:'Banana'}


TRAIN_PATH = '/kaggle/input/fruit-classification10-class/MY_data/train/'

def load_images_from_folder(folder_path, img_size=(100, 100)):
    images = []
    labels = []
    class_names = []


    for class_name in os.listdir(folder_path):
        class_path = os.path.join(folder_path, class_name)
        if os.path.isdir(class_path):
            class_names.append(class_name)
            if class_name in fruits.keys():
              for filename in os.listdir(class_path):
                  img_path = os.path.join(class_path, filename)
                  img = cv2.imread(img_path)

                  img = cv2.resize(img, img_size)
                  img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter para RGB
                  images.append(img)
                  labels.append(class_name)

    return np.array(images), np.array(labels), class_names

images, labels, class_names = load_images_from_folder(TRAIN_PATH)

images = images / 255
labels_normal = np.array( [fruits[x] for x in labels])
X_train, X_test, y_train, y_test = train_test_split(images, labels_normal, test_size=0.2, random_state=42)

"""# Apresentação do modelo de rede neural em Python"""

def create_simple_cnn():
    model = models.Sequential([
        # Primeira camada convolucional
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 3)),
        layers.MaxPooling2D((2, 2)),

        # Segunda camada convolucional
        layers.Conv2D(64, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),

        # Terceira camada convolucional
        layers.Conv2D(64, (3, 3), activation='relu'),

        # Camadas densas
        layers.Flatten(),
        layers.Dropout(0.5),  # Previne overfitting
        layers.Dense(64, activation='relu'),
        layers.Dense(3, activation='softmax')
    ])
    return model

model = create_simple_cnn()
model.summary()

# Compilando o modelo
# Utilizando o Modelo Adam, a função de perda para classficação categórica e métrica de acurácia
model.compile(
    optimizer = "adam",
    loss = "sparse_categorical_crossentropy",
    metrics=["accuracy"]
)

"""# Treinamento"""

history = model.fit(X_train, y_train, epochs=55, batch_size=32)

"""# Predição"""

test_loss, test_acc = model.evaluate(X_test, y_test)
print(f"Acurácia dos conjuntos de tests: {test_acc}")

predictions = model.predict(X_test)

for (index, prediction) in enumerate(predictions):
  index_pred_class = np.argmax(prediction)


  print(f"PRED: [{fruits_index_class[index_pred_class]}], REAL CLASS[{fruits_index_class[y_test[index]]}]")